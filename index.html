<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Bridge RT - Live Detection</title>
        <style>
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    sans-serif;
            }

            body {
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                background: #0f172a;
                color: #e2e8f0;
                padding: 20px;
            }

            .container {
                background: #1e293b;
                padding: 24px;
                border-radius: 12px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
                max-width: 1200px;
                width: 100%;
            }

            .header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 20px;
            }

            h1 {
                font-size: 1.8em;
                margin: 0;
                color: #f1f5f9;
            }

            .status {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 0.9em;
                color: #94a3b8;
            }

            #statusIndicator {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background-color: #ef4444;
                transition: background-color 0.3s ease;
            }

            #statusIndicator.connected {
                background-color: #22c55e;
            }

            .video-container {
                position: relative;
                width: 100%;
                background: #0f172a;
                border-radius: 8px;
                overflow: hidden;
                border: 1px solid #334155;
            }

            #videoCanvas {
                width: 100%;
                height: auto;
                display: block;
            }

            .stats {
                display: flex;
                justify-content: space-around;
                margin-top: 16px;
                padding: 12px;
                background: #334155;
                border-radius: 8px;
            }

            .stat {
                text-align: center;
            }

            .stat-label {
                font-size: 0.75em;
                color: #94a3b8;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .stat-value {
                font-size: 1.5em;
                font-weight: bold;
                color: #f1f5f9;
                margin-top: 4px;
            }

            .no-data {
                text-align: center;
                padding: 60px 20px;
                color: #64748b;
                font-size: 1.1em;
            }

            .mqtt-section {
                margin-top: 16px;
            }

            .mqtt-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 8px;
            }

            .mqtt-header h2 {
                font-size: 1em;
                color: #f1f5f9;
                margin: 0;
            }

            .mqtt-status {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.8em;
                color: #94a3b8;
            }

            #mqttIndicator {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background-color: #ef4444;
            }

            #mqttIndicator.connected {
                background-color: #22c55e;
            }

            .mqtt-messages {
                background: #0f172a;
                border-radius: 8px;
                padding: 12px;
                height: 200px;
                overflow-y: auto;
                font-family: "Monaco", "Menlo", monospace;
                font-size: 0.85em;
                border: 1px solid #334155;
            }

            .mqtt-message {
                padding: 8px 10px;
                margin-bottom: 6px;
                background: #1e293b;
                border-radius: 4px;
                border-left: 3px solid #3b82f6;
            }

            .mqtt-message:last-child {
                margin-bottom: 0;
            }

            .mqtt-message-time {
                color: #64748b;
                font-size: 0.75em;
                margin-bottom: 4px;
            }

            .mqtt-message-state {
                color: #f1f5f9;
                font-weight: bold;
            }

            .mqtt-message-state.tracking {
                color: #f87171;
            }

            .mqtt-message-state.standby {
                color: #4ade80;
            }

            .mqtt-message-state.validation {
                color: #facc15;
            }

            .mqtt-message-event {
                color: #94a3b8;
                font-size: 0.9em;
                margin-top: 2px;
            }

            .mqtt-empty {
                color: #64748b;
                text-align: center;
                padding: 20px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>Bridge RT - Live Detection</h1>
                <div class="status">
                    <div id="statusIndicator" title="Connection Status"></div>
                    <span id="statusText">Connecting...</span>
                </div>
            </div>

            <div class="video-container">
                <canvas id="videoCanvas"></canvas>
                <div id="noData" class="no-data">
                    Waiting for video stream...
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-label">Detections</div>
                    <div class="stat-value" id="detectionCount">-</div>
                </div>
                <div class="stat">
                    <div class="stat-label">FPS</div>
                    <div class="stat-value" id="fps">-</div>
                </div>
            </div>

            <div class="mqtt-section">
                <div class="mqtt-header">
                    <h2>State Changes (MQTT)</h2>
                    <div class="mqtt-status">
                        <div id="mqttIndicator"></div>
                        <span id="mqttStatusText">Disconnected</span>
                    </div>
                </div>
                <div class="mqtt-messages" id="mqttMessages">
                    <div class="mqtt-empty">Waiting for state changes...</div>
                </div>
            </div>
        </div>

        <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
        <script>
            const COLORS = [
                "#FF6B6B",
                "#4ECDC4",
                "#45B7D1",
                "#FFA07A",
                "#98D8C8",
                "#F7DC6F",
                "#BB8FCE",
                "#85C1E2",
                "#F8B739",
                "#52B788",
            ];

            // COCO class names indexed by (RF-DETR class ID - 1)
            // RF-DETR uses COCO's original non-contiguous IDs (1-90 with gaps)
            // Gaps at indices: 11, 25, 28, 29, 44, 65, 67, 68, 70, 82
            const COCO_CLASSES = [];
            COCO_CLASSES[0] = "person";
            COCO_CLASSES[1] = "bicycle";
            COCO_CLASSES[2] = "car";
            COCO_CLASSES[3] = "motorcycle";
            COCO_CLASSES[4] = "airplane";
            COCO_CLASSES[5] = "bus";
            COCO_CLASSES[6] = "train";
            COCO_CLASSES[7] = "truck";
            COCO_CLASSES[8] = "boat";
            COCO_CLASSES[9] = "traffic light";
            COCO_CLASSES[10] = "fire hydrant";
            // 11 is gap
            COCO_CLASSES[12] = "stop sign";
            COCO_CLASSES[13] = "parking meter";
            COCO_CLASSES[14] = "bench";
            COCO_CLASSES[15] = "bird";
            COCO_CLASSES[16] = "cat";
            COCO_CLASSES[17] = "dog";
            COCO_CLASSES[18] = "horse";
            COCO_CLASSES[19] = "sheep";
            COCO_CLASSES[20] = "cow";
            COCO_CLASSES[21] = "elephant";
            COCO_CLASSES[22] = "bear";
            COCO_CLASSES[23] = "zebra";
            COCO_CLASSES[24] = "giraffe";
            // 25 is gap
            COCO_CLASSES[26] = "backpack";
            COCO_CLASSES[27] = "umbrella";
            // 28, 29 are gaps
            COCO_CLASSES[30] = "handbag";
            COCO_CLASSES[31] = "tie";
            COCO_CLASSES[32] = "suitcase";
            COCO_CLASSES[33] = "frisbee";
            COCO_CLASSES[34] = "skis";
            COCO_CLASSES[35] = "snowboard";
            COCO_CLASSES[36] = "sports ball";
            COCO_CLASSES[37] = "kite";
            COCO_CLASSES[38] = "baseball bat";
            COCO_CLASSES[39] = "baseball glove";
            COCO_CLASSES[40] = "skateboard";
            COCO_CLASSES[41] = "surfboard";
            COCO_CLASSES[42] = "tennis racket";
            COCO_CLASSES[43] = "bottle";
            // 44 is gap
            COCO_CLASSES[45] = "wine glass";
            COCO_CLASSES[46] = "cup";
            COCO_CLASSES[47] = "fork";
            COCO_CLASSES[48] = "knife";
            COCO_CLASSES[49] = "spoon";
            COCO_CLASSES[50] = "bowl";
            COCO_CLASSES[51] = "banana";
            COCO_CLASSES[52] = "apple";
            COCO_CLASSES[53] = "sandwich";
            COCO_CLASSES[54] = "orange";
            COCO_CLASSES[55] = "broccoli";
            COCO_CLASSES[56] = "carrot";
            COCO_CLASSES[57] = "hot dog";
            COCO_CLASSES[58] = "pizza";
            COCO_CLASSES[59] = "donut";
            COCO_CLASSES[60] = "cake";
            COCO_CLASSES[61] = "chair";
            COCO_CLASSES[62] = "couch";
            COCO_CLASSES[63] = "potted plant";
            COCO_CLASSES[64] = "bed";
            // 65 is gap
            COCO_CLASSES[66] = "dining table";
            // 67, 68 are gaps
            COCO_CLASSES[69] = "toilet";
            // 70 is gap
            COCO_CLASSES[71] = "tv";
            COCO_CLASSES[72] = "laptop";
            COCO_CLASSES[73] = "mouse";
            COCO_CLASSES[74] = "remote";
            COCO_CLASSES[75] = "keyboard";
            COCO_CLASSES[76] = "cell phone";
            COCO_CLASSES[77] = "microwave";
            COCO_CLASSES[78] = "oven";
            COCO_CLASSES[79] = "toaster";
            COCO_CLASSES[80] = "sink";
            COCO_CLASSES[81] = "refrigerator";
            // 82 is gap
            COCO_CLASSES[83] = "book";
            COCO_CLASSES[84] = "clock";
            COCO_CLASSES[85] = "vase";
            COCO_CLASSES[86] = "scissors";
            COCO_CLASSES[87] = "teddy bear";
            COCO_CLASSES[88] = "hair drier";
            COCO_CLASSES[89] = "toothbrush";

            class BridgeRTViewer {
                constructor(url) {
                    this.socket = null;
                    this.url = url;
                    this.canvas = document.getElementById("videoCanvas");
                    this.ctx = this.canvas.getContext("2d");
                    this.statusIndicator =
                        document.getElementById("statusIndicator");
                    this.statusText = document.getElementById("statusText");
                    this.noData = document.getElementById("noData");

                    this.reconnectAttempts = 0;
                    this.maxReconnectAttempts = 10;

                    this.frameCount = 0;
                    this.lastFrameTime = Date.now();
                    this.fps = 0;

                    this.init();
                }

                init() {
                    this.connect();
                }

                connect() {
                    this.socket = new WebSocket(this.url);

                    this.socket.onopen = () => {
                        console.log("WebSocket connected");
                        this.statusIndicator.classList.add("connected");
                        this.statusText.textContent = "Connected";
                        this.reconnectAttempts = 0;
                    };

                    this.socket.onmessage = (event) => {
                        this.handleMessage(event.data);
                    };

                    this.socket.onclose = () => {
                        console.log("WebSocket disconnected");
                        this.statusIndicator.classList.remove("connected");
                        this.statusText.textContent = "Disconnected";
                        this.reconnect();
                    };

                    this.socket.onerror = (error) => {
                        console.error("WebSocket error:", error);
                        this.statusIndicator.classList.remove("connected");
                        this.statusText.textContent = "Error";
                    };
                }

                async handleMessage(data) {
                    try {
                        const buffer = await data.arrayBuffer();
                        const view = new DataView(buffer);
                        const jsonLength = view.getUint32(0, true);
                        const jsonBytes = new Uint8Array(buffer, 4, jsonLength);
                        const jsonText = new TextDecoder().decode(jsonBytes);
                        const metadata = JSON.parse(jsonText);

                        const jpegBytes = new Uint8Array(
                            buffer,
                            4 + jsonLength,
                        );
                        const jpegBlob = new Blob([jpegBytes], {
                            type: "image/jpeg",
                        });
                        const imageUrl = URL.createObjectURL(jpegBlob);

                        this.renderFrame(metadata, imageUrl);
                        this.updateStats(metadata);
                    } catch (error) {
                        console.error("Message parsing error:", error);
                    }
                }

                renderFrame(frame, imageUrl) {
                    this.noData.style.display = "none";

                    const img = new Image();
                    img.onload = () => {
                        this.canvas.width = frame.width;
                        this.canvas.height = frame.height;

                        this.ctx.drawImage(img, 0, 0);

                        if (frame.detections && frame.detections.length > 0) {
                            this.drawDetections(
                                frame.detections,
                                frame.width,
                                frame.height,
                            );
                        }

                        this.updateFPS();

                        URL.revokeObjectURL(imageUrl);
                    };

                    img.onerror = (e) => {
                        console.error("Image load error:", e);
                        URL.revokeObjectURL(imageUrl);
                    };

                    img.src = imageUrl;
                }

                drawDetections(detections, width, height) {
                    detections.forEach((det, idx) => {
                        const color = COLORS[det.class_id % COLORS.length];

                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = 3;
                        const boxWidth = det.x2 - det.x1;
                        const boxHeight = det.y2 - det.y1;
                        this.ctx.strokeRect(
                            det.x1,
                            det.y1,
                            boxWidth,
                            boxHeight,
                        );

                        const className =
                            COCO_CLASSES[det.class_id] ||
                            `Class ${det.class_id}`;
                        const label = `${className}: ${(det.confidence * 100).toFixed(1)}%`;
                        this.ctx.font = "bold 14px Arial";
                        const textWidth = this.ctx.measureText(label).width;

                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(
                            det.x1,
                            det.y1 - 22,
                            textWidth + 10,
                            22,
                        );

                        this.ctx.fillStyle = "#fff";
                        this.ctx.fillText(label, det.x1 + 5, det.y1 - 6);
                    });
                }

                updateStats(frame) {
                    document.getElementById("detectionCount").textContent =
                        frame.detections ? frame.detections.length : 0;
                }

                updateFPS() {
                    this.frameCount++;
                    const now = Date.now();
                    const elapsed = now - this.lastFrameTime;

                    if (elapsed >= 1000) {
                        this.fps = ((this.frameCount / elapsed) * 1000).toFixed(
                            1,
                        );
                        document.getElementById("fps").textContent = this.fps;
                        this.frameCount = 0;
                        this.lastFrameTime = now;
                    }
                }

                reconnect() {
                    if (this.reconnectAttempts < this.maxReconnectAttempts) {
                        this.reconnectAttempts++;
                        const delay = Math.min(
                            Math.pow(2, this.reconnectAttempts) * 1000,
                            30000,
                        );

                        console.log(`Reconnecting in ${delay / 1000}s...`);
                        this.statusText.textContent = `Reconnecting (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`;

                        setTimeout(() => this.connect(), delay);
                    } else {
                        console.error("Max reconnect attempts reached");
                        this.statusText.textContent = "Connection failed";
                    }
                }
            }

            class MqttClient {
                constructor(url, topic) {
                    this.url = url;
                    this.topic = topic;
                    this.client = null;
                    this.messages = [];
                    this.maxMessages = 50;

                    this.indicator = document.getElementById("mqttIndicator");
                    this.statusText = document.getElementById("mqttStatusText");
                    this.messagesContainer =
                        document.getElementById("mqttMessages");

                    this.connect();
                }

                connect() {
                    this.statusText.textContent = "Connecting...";

                    this.client = mqtt.connect(this.url, {
                        reconnectPeriod: 1000,
                        connectTimeout: 5000,
                    });

                    this.client.on("connect", () => {
                        console.log("MQTT connected");
                        this.indicator.classList.add("connected");
                        this.statusText.textContent = "Connected";

                        this.client.subscribe(this.topic, (err) => {
                            if (err) {
                                console.error("MQTT subscribe error:", err);
                            } else {
                                console.log(`Subscribed to ${this.topic}`);
                            }
                        });
                    });

                    this.client.on("message", (topic, message) => {
                        try {
                            const data = JSON.parse(message.toString());
                            this.addMessage(data);
                        } catch (e) {
                            console.error("Failed to parse MQTT message:", e);
                        }
                    });

                    this.client.on("close", () => {
                        this.indicator.classList.remove("connected");
                        this.statusText.textContent = "Disconnected";
                    });

                    this.client.on("error", (err) => {
                        console.error("MQTT error:", err);
                        this.indicator.classList.remove("connected");
                        this.statusText.textContent = "Error";
                    });

                    this.client.on("reconnect", () => {
                        this.statusText.textContent = "Reconnecting...";
                    });
                }

                addMessage(data) {
                    this.messages.unshift(data);
                    if (this.messages.length > this.maxMessages) {
                        this.messages.pop();
                    }
                    this.renderMessages();
                }

                renderMessages() {
                    if (this.messages.length === 0) {
                        this.messagesContainer.innerHTML =
                            '<div class="mqtt-empty">Waiting for state changes...</div>';
                        return;
                    }

                    this.messagesContainer.innerHTML = this.messages
                        .map((msg) => {
                            const time = new Date(msg.timestamp).toLocaleTimeString();
                            const stateClass = msg.state.toLowerCase();
                            const eventLabel = this.formatEvent(msg.event_type);

                            return `
                            <div class="mqtt-message">
                                <div class="mqtt-message-time">${time} - ${msg.device_id}</div>
                                <div class="mqtt-message-state ${stateClass}">${msg.state}</div>
                                <div class="mqtt-message-event">${eventLabel}</div>
                            </div>
                        `;
                        })
                        .join("");
                }

                formatEvent(eventType) {
                    const labels = {
                        human_detected: "Human detected in frame",
                        standby_resumed: "No humans - entering standby",
                        validation_started: "Validating detection...",
                    };
                    return labels[eventType] || eventType;
                }
            }

            const viewer = new BridgeRTViewer("ws://localhost:8080/ws");
            const mqttClient = new MqttClient(
                "ws://localhost:9001",
                "detr-mmap/controller/state",
            );
        </script>
    </body>
</html>
